from time import time
import copy
import sys
import itertools as it
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

from Initial_Alg import Alg
from Column_Gen import ColumnGeneration as CG
from Column_Gen import Master, Sub_model
from utils import Obj_Calc
from BnP import Master_int, Cuts
from utils import utils, Seq


def calculate_the_obj(Data, R, Routes, RDPs):
    Gc = Data.Gc
    # create the mapping to find the node quantities  :))
    Q_mapping = {}
    for i in Gc.nodes:
        for r_ID, route in enumerate(Routes):
            inx = np.where(np.array(route.route) == i)[0]
            if len(inx) != 0:
                inx = inx[0]
                break
        Q_mapping[i] = (r_ID, inx)

    part1 = 0
    for i in Gc.nodes:
        (r_ID, inx) = Q_mapping[i]
        part1 += Gc.node[i]['demand'] - RDPs[r_ID][inx]

    part2 = 0
    for i, j in it.product(Gc.nodes, Gc.nodes):
        (r_IDi, inxi) = Q_mapping[i]
        (r_IDj, inxj) = Q_mapping[j]
        part2 += abs(Gc.node[j]['demand']*RDPs[r_IDi][inxi] - Gc.node[i]['demand']*RDPs[r_IDj][inxj])

    part2 = (Data.Lambda / Data.total_demand) * part2
    part3 = Data.Gamma * (Data.Total_dis_epsilon - sum([r.travel_time for r in Routes])) / R

    return part1+part2+part3


class Node:
    best_Route = []
    best_RDP = []
    UpperBound = float("Inf")
    LowerBound = 0
    time2UB = - 10
    Data = None
    R = None

    Node_dic = {0: []}
    Node_dic2 = {}
    NodeCount = 0
    Tree = nx.Graph()
    
    def __init__(self, ID,  PID, level, pos, Col_dic, G, edge2keep={}, edge2avoid={}, cuts=[], Initial_RDP=None):
        
        self.level = level
        self.ID = ID
        self.Parent_ID = PID
        self.pos = pos
        self.Col_dic = Col_dic
        self.G = copy.deepcopy(G)
        self.edges2keep = edge2keep
        self.edge2avoid = edge2avoid
        self.lower_bound = 0
        self.selected_R_D = []
        self.selected_route = []
        self.feasible = self.check_G_feasibility()
        self.Dis = Node.Data.distances
        self.Col_runtime = 0
        self.cuts = cuts
        self.upper_bound, self.Int_route, self.Int_RDP = float("Inf"), None, None

        if self.feasible:
            # Add feasible solutions to the Col Dic by initial heuristic
            self.Run_initial_heuristic()
            if self.feasible:
                # solve with column generation
                self.solve()
                # self.Upper_bound_finder()

        # Extra information (Save the nodes and complete the tree fro drawings)
        Node.NodeCount += 1
        '''        
        Node.Node_dic2[self.ID] = self
        if level < len (Node.Node_dic):
            Node.Node_dic[level].append(self)
        else:
            Node.Node_dic[level]=[self]
        '''
        Node.Tree.add_node(self.ID)
        Node.Tree.add_edge(self.Parent_ID, self.ID)

    def __repr__(self):
        return f"Node {self.ID}: LB: {round(self.lower_bound,2)} UB: {round(self.upper_bound, 2)}"

    def Run_initial_heuristic(self):
        # This function Generates some new R_D according to new dis (edges to avoid)
        F_Sols, self.feasible = Alg.Initial_feasibleSol(Node.Data, self.Dis, edges2keep=self.edges2keep,
                                           edges2avoid=self.edge2avoid)
        new_routes = []
        if self.feasible:
            for sol in F_Sols:
                if sol.obj < self.upper_bound:
                    self.upper_bound = sol.obj
                    self.Int_route = sol.routes
                new_routes += sol.routes
        else:
            print("Initial heuristic says Infeasible")

        # Add the newly generated columns to the Col_dic
        for R_D in new_routes:
            if 0 in R_D.nodes_in_path:
                sys.exit("0 in the route in new cols generated by initial heuristics")
            unique, inx = R_D.Is_unique(self.Col_dic)
            if unique == 1:
                self.Col_dic[inx] = copy.copy(R_D)
            elif unique == 2:
                self.Col_dic[inx].add_RDP(R_D.RDP[1])
            elif unique == 3:
                pass

    def solve(self):
        # This function solves a node (integer relaxation) by column generation

        # Build the master problem
        RMP = Master.MasterModel(Node.Data, self.Col_dic, Node.R, self.edges2keep)
        # Build the sub-problem only the constraints and variables 
        Sub = Sub_model.SubProblem(Node.Data, self.G, self.Dis, self.edges2keep, self.edge2avoid)
        # Add cuts from previous node in BnP tree
        RMP = Cuts.update_master_subrow_cuts(RMP, self.Col_dic, len(self.cuts), self.cuts)
        Sub = Cuts.update_subproblem_with_cuts(Sub, len(self.cuts), self.cuts)
        # Start the Column Generation
        start = time()
        while 1:
            self.feasible, RMP, self.lower_bound, self.Y, self.Col_dic = CG.ColumnGen(Node.Data, Node.R, RMP, self.G, self.Col_dic,
                                                                           self.Dis, self.edges2keep, self.edge2avoid, Sub, self.cuts)

            utils.check_branching(self.Col_dic, self.edge2avoid, self.edges2keep)
            if not self.feasible: break
            print(f"Current lowerbound in Node {self.ID}: {self.lower_bound}")
            # Add cuts
            new_subrow_cuts = []
            # new_subrow_cuts = Cuts.separation_subrow(Node.Data, self.Col_dic, self.Y, self.cuts)
            self.cuts += new_subrow_cuts
            if len(new_subrow_cuts):
                print(f"Number of cuts added : {len(new_subrow_cuts)}")
                RMP = Cuts.update_master_subrow_cuts(RMP, self.Col_dic, len(self.cuts), new_subrow_cuts)
                Sub = Cuts.update_subproblem_with_cuts(Sub, len(self.cuts), new_subrow_cuts)
            else:
                break

        self.Col_runtime = time()-start
        if self.feasible:
            self.selected_R_D = [a for a in self.Y.keys() if self.Y[a] != 0]

    def Strong_Branching(self):
        # Find the branching rule
        Edge_Val = {}
        # calculate the xij values ***** Not for   i--NN+1 ******
        
        for edge in self.G.edges():
            if Node.Data.NN+1 not in edge: #Do not branch on i-NN+1 edges
                Edge_Val[edge] = abs(sum([utils.edge_in_route(edge, self.Col_dic[Col_ID]) * self.Y[Col_ID, RDP_ID]
                                          for Col_ID, RDP_ID in self.selected_R_D]) - 0.5)

        # find the one with\ the minimum 
        
        while 1:
            selected_edge = min(Edge_Val, key=Edge_Val.get)
            if selected_edge in self.edge2avoid["E"]:
                del Edge_Val[selected_edge]
            elif selected_edge in self.edges2keep["E"]:
                del Edge_Val[selected_edge]
            else:
                break

        counter = 0
        for key, val in Edge_Val.items():
            if val <= 1.1 * Edge_Val[selected_edge]:
                counter += 1
        print("I select the branching edges among %d alternative randomly!!" %counter)
        L_Node = self.Arc_Branching("left", *selected_edge)
        R_Node = self.Arc_Branching("right", *selected_edge)
        
        return [L_Node, R_Node]
        
    def Arc_Branching(self, WhichNode, i, j):
        # This function will branch on given edge and generates 2 child nodes
        
        Col_dic = copy.deepcopy(self.Col_dic)
        G = copy.deepcopy(self.G)
        
        if WhichNode == "left":

            # update the avoid edges
            edge2avoid = copy.deepcopy(self.edge2avoid)
            edge2avoid["E"].append((i, j))
            for n1, n2 in [(i, j), (j, i)]:
                if n1 in edge2avoid["N"].keys():
                    edge2avoid["N"][n1].append(n2)
                else:
                    edge2avoid["N"][n1] = [n2]
            # create the new seq list
            Node.Data.All_seq, _ = Seq.Create_seq(Node.Data, self.edges2keep["N"])

            # update the set columns by removing edge i-j or j-i
            for inx, R_D in self.Col_dic.items():
                if utils.edge_in_route((i, j), R_D):
                    del Col_dic[inx]

            # update the graph as well
            G.remove_edge(i, j)

            return Node(Node.NodeCount, self.ID, self.level+1, WhichNode, Col_dic, G,
                        cuts=self.cuts, edge2avoid=edge2avoid, edge2keep=self.edges2keep)

        elif WhichNode == "right":

            # update the keep edges
            edges2keep = copy.deepcopy(self.edges2keep)
            edges2keep["E"].append((i, j))
            for n1, n2 in [(i, j), (j, i)]:
                if n1 in edges2keep["N"].keys():
                    edges2keep["N"][n1].append(n2)
                else:
                    edges2keep["N"][n1] = [n2]

            # create the new seq list
            Node.Data.All_seq, _ = Seq.Create_seq(Node.Data, edges2keep["N"])

            new_cols = {}  # keep the RD that have i-j or j-i Ot niether of them
            for inx, R_D in Col_dic.items():
                if R_D.is_visit(i) or R_D.is_visit(j):
                    if utils.edge_in_route((i, j), R_D):  # check if it have either for i-j and j-i
                        Updated_R_D, _ = utils.build_the_route(Node.Data, route=R_D.nodes_in_path)
                        Updated_R_D.RDP = R_D.RDP
                        new_cols[inx] = Updated_R_D
                    else:
                        if i == 0 and not R_D.is_visit(j):  # If i is 0 and j is not in route
                            new_cols[inx] = R_D
                else:
                    # If the route do not have both i and j
                    new_cols[inx] = R_D

            Col_dic = new_cols

            return Node(Node.NodeCount, self.ID, self.level+1, WhichNode, Col_dic, G,
                        cuts=self.cuts, edge2avoid=self.edge2avoid, edge2keep=edges2keep)

    def check_G_feasibility(self):
        # This function performs some feasibility test on the graph

        # if the graph is still connected
        subturs = [c for c in sorted(nx.connected_components(self.G), key=len, reverse=True)]
        if len(subturs) != 1:
            # Graph became disconnected
            return 0

        # more then two must-visited-edges are connected to one node
        G2 = nx.Graph()
        G2.add_nodes_from(self.G.nodes())
        for key, val in self.edges2keep.items():
            for v in val:
                G2.add_edge(key, v)

        for i in G2.nodes():
            if G2.degree(i) >= 3:
                return 0

        # the degree of depot node shouldn't be larger than number of vehicles
        if G2.degree(0) > Node.Data.M:
            return 0

        # every cycle should have depot inside
        cycles = nx.cycle_basis(G2)
        for c in cycles:
            if 0 not in c:
                return 0

        # there is no edge edge to branch
        edgeset = list(self.G.edges())
        for n in self.G.nodes:
            if n != 0 and n != Node.Data.NN + 1:
                edgeset.remove((n, Node.Data.NN + 1))
        # print("Number of existed edges: %s" %(len(edgeset)-Node.Data.NN+1))

        if not edgeset:
            return 0

        return 1

    def integer(self):
        # This function checks if all master problem variables are integer or not
        if self.feasible:
            indictor = all( [self.Y[i] - int(self.Y[i]) < 0.00001 for i in self.Y.keys()] )
        else:
            indictor = False

        if indictor:
            self.upper_bound = self.lower_bound
            self.Int_route = [self.Col_dic[i] for (i, j), val in self.Y.items() if val > 0.9]

        return indictor
    
    def delete(self):
        del self.G
        del self

    @classmethod
    def LB_UB_GAP_update(cls, stack, node, start):
        if Node.LowerBound < node.lower_bound <= stack[0].lower_bound:
            Node.LowerBound = node.lower_bound
        if node.upper_bound < Node.UpperBound:
            Node.UpperBound = node.upper_bound
            Node.time2UB = round(time() - start, 3)
            if node.integer():
                for (r, id), val in node.Y.items():
                    if val > 0.9:
                        Node.best_Route.append(node.Col_dic[r])
                        Node.best_RDP.append(node.Col_dic[r].RDP[id])
            else:
                Node.best_Route = node.Int_route
                Node.best_RDP = node.Int_RDP

        Node.Gap = round((Node.UpperBound-Node.LowerBound)*100/Node.UpperBound, 3)

    @classmethod
    def reset(cls):
        Node.best_Route = []
        Node.best_RDP = []
        Node.UpperBound = float("Inf")
        Node.LowerBound = 0
        Node.time2UB = - 10
        Node.Data = None
        Node.R = None

        Node.Node_dic = {0: []}
        Node.Node_dic2 = {}
        Node.NodeCount = 0
        Node.Tree = nx.Graph()

    def Update_shortest_dis(self):
        # @ TODO this function is not in use
        # change the dis matrix to avoid deleted edges in initial heuristic
        # This is needed for left nodes and the nodes under them
        # We use bellman ford algorithm to find al pair short beasd on new Graph
        # Dis=nx.all_pairs_bellman_ford_path_length(self.G,  weight='Travel_time')

        paths = dict(nx.all_pairs_bellman_ford_path(self.G))
        for i, j in it.combinations(self.G.node, 2):
            path = paths[i][j]
            travel_dis = 0
            pernode = path.pop(0)
            while len(path):
                Cnode = path.pop(0)
                travel_dis += self.G.edges[pernode, Cnode]["Travel_distance"]
                pernode = Cnode
            self.Dis[i, j] = travel_dis
            self.Dis[j, i] = travel_dis

    def Upper_bound_finder(self):
        # @TODO I do not use this any more for two reasons
        #  1- initial heuristic can find better solution
        #  2- it is time consuming
        self.Int_Objval, self.Int_route, self.Int_RDP = Master_int.Master_int(Data, R, Node.best_obj, self.Col_dic)

    @classmethod
    def Draw_the_tree(cls):
        # @ TODO this function is not in use
        # This function draws the Branch and bound tree 
        W = 100
        label_dic = {} # lable dictionery
        pos = {} # node position dictionery
        x = {0: W/2}
        y = {}
        color_map = []
        maxlevel = len(Node.Node_dic)
        Ystep = W/maxlevel
        for le in range(maxlevel):
            NfNodes = len(Node.Node_dic[le])
            Xstep = W/4*NfNodes
            Node.Node_dic[le] = sorted(Node.Node_dic[le], key=lambda x: x.Parent_ID)
            for inx,n in enumerate(Node.Node_dic[le]):
    
                if n.pos == "left":
                    x[n.ID] = x[Node.Node_dic2[n.Parent_ID].ID] - Xstep
                elif n.pos == "right":
                    x[n.ID] = x[Node.Node_dic2[n.Parent_ID].ID] + Xstep
                else:
                    x[n.ID] = x[Node.Node_dic2[n.Parent_ID].ID]
              
                y[n.ID] = 100 - Ystep * n.level
                pos[n.ID] = (x[n.ID], y[n.ID])
                if not n.feasible:
                    label_dic[n.ID] = "IF-%d " % n.ID
                elif n.integer():
                    label_dic[n.ID] = "IN-%d \n %s" % (n.ID, round(n.lower_bound, 1))
                else:
                    label_dic[n.ID] = "%d-%d" % (n.ID, round(n.lower_bound, 1))

        '''
        for n in Node.Node_list:
            if not n.feasible:
                color_map.append('red')
            elif n.integer:
                color_map.append('green')
            else:
                color_map.append('blue')
        '''     
           
        plt.title("Branch and price tree")
        
        nx.draw(Node.Tree, node_size=700,  node_color = color_map,labels=label_dic, with_labels = True,pos=pos, node_shape='s')
        
        plt.show()

